## Overview

## Web page Basics
### Format of Web Page Markup
Documents can be presented in many forms. A simple editor like IDLE or Windows'
Notepad produce plain text: essentially a long string of meaningful characters.

Documents can be displayed with formatting of parts of the document. Web pages
allow different fonts, italic, and boldfaced emphases, and different sized text,
all to be included. Microsoft World, Open Office, and Latex, all display documents
with various amounts of formatting. The syntax for the ways different systems _encode_
the formatting information varies enormously.

If you look at an old Microsoft Word .doc document in a plain text editor like Notepad,
you should be able to find the original text buried inside, but most of the symbols 
associated with the formatting are unprintable gibberish as far as a human is concerned.

Hypertext Markup Language (HTML) is very different in that regard. It produces a file of entirely
human-readable characters, that could be produced with a plain text editor.

For instance in HTML, the largest form of a heading with the text "Web Introduction", would look like
```
<h1>Web Introcudtion</h1)
```
The heading format is indicated by bracketing the heading text 'Web Introduction' with markup sequences,
`<h1>` beforehand, and `</h1>` afterward. All HTML markup is delimited by **_tags_** enclosed in angle
brackets, and most tags come in pairs, surrouding the information to be formatted. The end tag has
an extra `/`. Here `h` stands for heading, and the number indicates the relative importance of the 
heading. (There is also h2, h3, ... for smaller headings.) In the early days of HTML, editing was
done in a plain text editor, with the tags being directly typed in by people who memorized all the codes!

With the enormous explosion of the World Wide Web, specialized software has been developed to make
web editing be much like word precessing, with a graphical interface, allowing formatting to be done
by selecting text with a mouse and clicking menus and icons labeled in more natural language. The
software then automatically generates the necessary makrup.

### Introduction to Static Pages in Kompozer
This section introduces the Kompozer web page eidtor to create **_static_** pages. A **_static_**
page is one that is created ahead of time and just opened and used as needed. This is as opposed to 
a **_dynamic_** page, which is a custom page generated by software on demand, given some input parameters.

Kompozer is used because it is free software, and is pretty easy to use, like a common word processor.
Unlike a common word porcessor you will be able to easily look at the HTML markup code underneath.
It is not necessary to know a lot about the details of the markup codes for HTML files to use Kompozer,
but you can see the result of the markup.

We will use static pages later as a part of making dynamic pages, using the static pages as templates
in which we insert data dynamically.

To creating static web pages:
1. If you are in a Loyola University Windows lab, following the sequence of selections `Start
menu > Loyola software > Math and Computer Science > Kompozer`. (It may be uder Internet instead'
of Math and Computer Science instead.) You may get pop-up window wanting to count users to 
Kompozer. Click OK as another user of Kompozer.

2. However you start Kompozer, go to the menu in Kompozer and select File > New. You will get waht 
looks like an empty document.

3. Look at the bottom of your window. You should see a **Normal** tab selected, with other
choices beside it, including a **source** tab. Click on the **Souce** tab. You should see that,
though you have added no content, you already have the basic markup to start an HTML page!

4. Click again on the Normal tab to go back to the Normal view (of no content at the moment).

5. Assume you are making a home page for yourself. Make a title and some introductory text.
Use regular word processor features like marking your title as Heading 1 in the drop down box
on a menu bar. (The drop down menu may start off displaying 'Paragraph' or 'Body Text'.) You can
select text and make it bold or italics; enlarge it ... using the editing menu or icons.

6. Before getting too carried away, sava your document as index.html in the existing _www directory
under your earlier Python examples__. It will save a lot of trouble if you keep your web work together
in this www directory, where I have already placed a number of files you will want to keep together
in one directory.

7. Just for comparison, switch back and forth between the Normal and Source views to see all that
has gone on underneath your view, particularly if you edited the format of your text. Somewhere embedded
in the Source view you should see all the text you entered. Some individual characters have special
symbols in HTML that start with an ampersand and end with a semicolon. Again, it is more important 
the understand that there are two different views than to be able to reproduce the Source view from memory.

8. You can use your web browser to see how your file looks outside the editor. The easiest way to do
this is to go to the web browser's menu and select something like `File > Open File`, and find the 
_index.html_ file you just wrote. It should look pretty similar to the way it looked in Kompozer, but if 
you put in hyperlinks, they should now be active.

The discussion of web page editting continues in Editing HTML Forms, but first we get Python into
the act.

### Editing and Testing Different Document Formats
> Note: In this chapter you will be working with several different types of documents that you will 
edit and test in very different ways. The ending of their names indicate their use.

Each time a new type of file is discussed in later sections, the proper ways to work with it
will be repeated, but with all the variations, it is useful to group them all  in one place now:
```
...Web.py
    My convention for regular Python programs taking all their input from the keyboard, and producing
    output displayed on a web page. These programs can be run like other Python programs, directly
    from an operating system folder or from inside IDLE. They are not a final product, but are
    a way of breaking the development process into steps.
    
...cgi
    Python program to be run by a web server. You will develop code useing a local web server on your
    own machine.
    
...html
    Web documents most often composed in an editor like Kompozer. By _my_ convention, these have
    a sub-categories.
    
    ...Template.html
        not intended to be displayed directly in a browser, but instead are read by a Python
        program (...cgi or ...Web.py) to create a template or format string for a final web
        page that is dyanmically generated inside the Python program.
        
     Other files ending in .html are intended to be directly viewed in a web browser. Except for
     the simple static earlier examples in Introduction to Static Pages in Kompozer, they are
     designed to reside on a web server, where they can pass information to a Python CGI program
     (...cgi).
```
To make this work on your computer:

1. Hava all the web pages in the same directory as the example program localCGIServer.py.
It is easiest to leave it in the www subdirectory of your examples directory.

2. Inculde the Python CGI server programs in the same directory.

3. Hava localCGIServer.py running, started from a directory window, not from inside IDLE.

4. In the browser URL field, the web page file name must be proceded by http://localhost:8080/.
For example, http://localhost:8080/adder.html would refer to the file adder.html, in the same
directory as the running localCGIServer.py. The URL may either by an html file or possibly a 
CGI file. For example, http://localhost:8080/now.cgi would call the file now.cgi (assuming it is 
in the same directory as the running localCGIServer.py).

5. Most often CGI programs are referenced in a web form, and the program is called _indirectly_
by the web server. CGI programs can be edited and saved inside IDLE. They must be run via the 
server/browser combination. More on this later.

## Composing Web Pages in Python
### Dynamically Created Static Local Pages from Python

For the rest of this chapter, the example files will come from the www directory
under the main examples directory you unzipped. I will refer to example file
there as "example www files".

As the overview indicated, dynamic web applications typically involve getting input
from a web page form, processing the input to a web page. Introducing all these
new ideas at once could be a lot to absorb, so this secton treats only the last part,
output to the web, and uses familiar keyboard input into a regular Python program.

Follow this sequence of steps:

1. Open the example www file `hello.html` in your browser, to see what it looks like.

2. Change your browser view - for instance go back to the previous page you displayed.

3. Open the same hello.html file in Kompozer.

4. In kompozer, switch to the Source view (clicking the Source tab). sometimes you 
will want to copy HTML text into a Python program. For instance, I selected and 
copied the entire contents of the `hello.html` source view and pasted it into a
multi-line string in the Python program shown and discussed below.

5. Careful, note the change from past practice here: Start Python from inside the 
www directory. In Windows start the IDLE shortcut link that I placed in the www directory,
not the original example directory.

6. Open the www example program `helloWeb1.py` in an IDLE edit window.

7. Run it.

You should see a familiar web page appear in your default browser (possibly not 
the one you have been using). This is obviously not a very necessary program, since
you can select this page directly in your browser! Still, one step at a time: it
illustrates several useful points. The program is copied below. 

Read it:
```
'''A simple program to create an html file from given string, 
and call the default web browser to display the file.'''

contents = '''<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Hello</title>
</head>
<body>
Hello, World!
</body>
</html>
'''
def main():
    browseLocal(contents)
   
def strToFile(text, filename):
    """Write a file with the given name and the given text."""
    output = open(filename, "w")
    output.write(text)
    output.close()
    
def browseLocal(webpageText, filename='tempBrowseLocal.html'):
    '''Start your webbrowser on a local file containing the text with given filename.'''
    import webbrowser, os.path
    strToFile(webpageText, filenaem)
    webbrowser.open("file:///" + os.path.abspath(filename))   #elaborated for Mac

main()
```
This program encapsulates two basic operations into the last two functons that will be used __over__ and __over__.
The first, `strToFile`, has nothing new, it just puts specified text in a file with a specified name. The second, 
`browseLocal`, dose more. It makes specified text(presumably a web page), puts it in a file, and directly displays
the file in your web browser. It uses the `open` function from the `webbrowser` module do start the new page in your
web browser. The open function here requires the name of a file or URL. Since the page is automatically generated
by the program for one-time immediate viewing, it automatically uses the same throwaway filename, `tempBrowseLocal.html`.

In this particular program the text thet goes in the file is just copied from the literal string named `contents` in the program.

This is no advance over just opening the file in the browser directly! Still, it is a start towards the aim of creating web content dynamically.

An early example in this tutorial displayed the fixed `Hello World!` to the screen. This was later modified in `hello_you4.py` to incorporate user input using the string format method of Dictonaries and String Formatting.

```
person = input('Enter your name: ')
greeting = 'Hello {person}!'.format(**locals())
print(greeting)
```
Similarly, I can turn the web page contents into a format string, and insert user data. Load and run the www example program `helloWeb2.py`.

The simple changes from `helloWeb1.py` are marked at the beginning of the file and shown below. I modified the web page text
to contains 'Hello, {person}!' in place of 'Hello, World!', making the string into a format string, which I renamed to the more appropriate `pageTemplate`. The changed initial portion with the literal string and the main program then becomes
```
pageTemplate = '''
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Hello</title>
</head>
<body>
Hello, {person}!
</body>
</html>''' # NEW note '{person}' two lines up

def main():    # NEW
    person = input("Enter a name: ")  
    contents = pageTemplate.format(**locals())   
    browseLocal(contents) 
```
Now the line
```
contents = pageTemplate.format(**locals())
```
incorporaties the person's name into the contents for the web page before saving it to a file and displaying it.

In this case, I stored the literal format string inside the Python program, but consider a different approach:

Load and run the www example program `helloWeb3.py`. It behaves exactly like helloWeb2.py, but is slightly different internally - it does not directly contain the web page template string. Instead the web page template string is read from the file `helloTemplate.html`.

Below is the beginning of helloWeb3.py, showing the only new functions. The first, `fileToStr`, will be a standard function used in the future. It is the inverse of `strToFile`.

The main program obtains the input. In this simple example, the imput is used directly, with little further processing. It is inserted into the web page, using the file `helloTemplate.html` as a format string.
```
def fileToStr(fileName):  # NEW
    """Return a string containing the contents of the named file."""
    fin = open(fileName)
    contents = fin.read()
    fin.close()
    return contents
    
def main():
    person = input('Enter a name: ')
    contents = fileToStr('helloTemplate.html')
    browseLocal(contents)
```
Althought `helloTemplate.html` is not intended to be viewed by the user (being a template), you should open it in a web editor (like Kompozer) to look at it. It is legal to create a web page in a web page editor with expressions in braces embedded in it! If you look in the Source view in Kompozer you will see something similar to the literal string in helloWeb2.py, except the lines are broken up differently. (This makes no difference in the formatted result, since in html, all white space is considered the same.)

Back in the Normal mode, add some formatting like italics, and an extra line of text, and save the file again (under the same name). Run the program `helloWeb3.py` again, and see that you have been able to change the appearance of the output without changing the Python program itself. That is the aim of using the template html page, allowing the web output formatting to be managed mostly independently from the Python program.

A more conplicated but much more common sutuation is where the input data is processed and transformed into results somehow, and these results, often along with some of the original input, are embedded in the web page that is produced.

As a simple example, load and run the www example program `additionWeb.py`, which uses the template file `additionTemplate.html`.

The aim in the end of this chapter is to have user input come from a form on the web rather than the keyboard on a local machine, but in either case the input is still transformed into results and all embedded in a web page. To make parts easily reusable, I obtain the input in a distinct place from where the input is processed. In keeping with the later situation with web forms, all input is of string type (using keyboard `input` for now).

Look at the program. You will see only a few new lines! Because of the modular design, most of the program is composed of recent standard functions reused.

The only new codes is at the beginning and is shown here:
```
def processInput(numStr1, numStr2):   # NEW
    '''Process input parameters and return the final page as a string.'''
    num1 = int(numStr1)   # transform input to output data
    num2 = int(numStr2)
    total = num1 + num2
    return fileToStr('additonTemplate.html').format(**locals())
    
def main():   # NEW
    numStr1 = input('Enter an integer: ')   # obtain input
    numStr2 = input('Enter another integer: ')
    contents = processInput(numStr1, numStr2)   # process input into a page
    browseLocal(contents)   # display page
```
The input is obtained (via `input` for now), and it is processed into a web page string, and as a separate step it is displayed in a local web page.
    
There are a few things to note:
* All input is strings. Before the numerical calculations, the digit strings must be converted to integers.

* I do calculate (a very simple!) result and use it in the output web page.

* Although it is not in the Python code, an important part of the result comes from the web page format string in additionTemplate.html, which includes the needed variable names in braces, {num1}, {nub2}, and {total}. View it in your browser or in Kompozer.

When you write your own code, you might modify `additonWeb.py`, or you can start from a stripped down skeleton with comments about where to insert your special code, `skeletonForWeb.py`.

We will examine the bottom part of the following diagram later. The top part outlines the flow of data from string input to web page in your browser for a regular Python program like what we have been describing.

Again, this last section was somewhat artificial. You are not in the end likely to find such programs practical as end products. However such programs are reasonable to write and test and they include almost all the code you will need for a more practical (but harder to debug) CGI program, coming next...

## CGI - Dynamic Web Pages
CGI stands for Common Gateway Interface. This interface is used by web servers to process information requests supplied by a browser. Python has modules to allow programs to do this work. The convention used by many servers is to have the server programs that satisfy this interface end in ‘.cgi’. That is the convention used below. All files below ending in ‘.cgi’ are CGI programs on a web server, and in this chapter, they will all be Python programs (though there are many other languages in use for this purpose). These programs are often called scripts, so we will be dealing with Python CGI scripts.

### An Example in Operation
The first part of this secton requires you to have access to the Internet. Later you will also see what you can illustrate the exact same actions on your own local machine.

For a very simple but complete example, use your browser to go to the page on the public Loyola server, http://anh.cs.luc.edu/python/hands-on/3.1/examples/www/adder.html. You see a web form. Follow the instructions, enter number, and click on the Find Sum button. You get back a page that obviously used your data. This is the idea that you can generalize. First consider the basic execution steps behind the scene:

1. The data you type is handled directly by the browser. It recognizes forms.

2. An action instruction is stored in the form saying what to do when you press a button indicating you are ready to precess the data (the Find Sum button in this case).

3. In the cases we consider in this tutorial, the action is given as a web resource, giving the location of a CGI script on some server (in our cases, the same directory on the server as the current web page).

4. When you press the button, the browser sends the data that you entered to that web location (in this case adder.cgi in the same folder as the original web page).

5. The server recognizes the web resource as an executable script, sees that it is a Python program, and executes it, using the data sent along from the browser form as input.

6. The script runs, manipulates its input data into some results, and puts those results into the text of a web page that is the output of the program.

7. The server captures this output from the program and sends it back to your browser as a new page to display.

8. You see the results in your browser.

This also works locally, entirely on your own computer, using a simple server built into Python. (Internet no longer needed!)

Windows

In an operating system file window, go to the folder with the www examples. Double click on localCGIServer.py to start the local, internal, web server. You should see a console window pop up, saying “Localhost CGI server started” .

Mac

This is more involved. See http://anh.cs.luc.edu/python/hands-on/3.1/pythonOnMac.html.

Once the server is started, leave the console window there as long as you want the local server running.

> Warning: Do not start the local server running from inside IDLE

> Note: If the server aborts and gives an error message about spaces in the path, look at the path through the parent directories voer this www directory. If any of the directory names hava spaces in them, the local file server will not work.

In case of this error, either go up the directory chain and alter the directory names to eliminate spaces or move the examples directory to a directory that does not have this issue. In particular, you need to move your examples directory if it is under the ‘My Programs’ directory.

Back in the www directory, after you have the local server going,

1. Open the web link http://localhost:8080/adder.html (preferably in a new window, separate from this tutorial).

2. You should see an adder form in your browser again. Note that the web address no longer includes ‘cs.luc.edu’. Instead it starts with ‘localhost:8080’, to reference the local Python server you started. Fill out the form and test it as before.

3. Look at the console window. You should see a log of the activity with the server. Close the server window.

4. Reload the web link http://localhost:8080/adder.html. You should get an error, since you refer to localhost, but you just stopped the local server.

For the rest of this chapter, we will be wanting to use the local server, so restart localCGIServer.py from its operating system folder, and keep it going.

### A simple Buildup
Before we get too complicated, consider the source code of a couple of even simpler examples.

**hellotxt.cgi**

The simplest case is a CGI script with no input that just generates plain text, rather than HTML. Assuming you have your local server going, you can go to the link for hellotxt.cgi, http://localhost:8080/hellotxt.cgi. The code is in the www example directory, hellotxt.cgi, and below for you to read:
```
#!/usr/bin/env python3

# Required header that tells the browser how to render the text.
print("Content-Type: text/plain\n\n")  # here text -- not html

# Print a simple message to the display window.
print("Hello, World!\n")
```
The top line is what tells the operating system that this is a Python 3 program. It says where to find the right Python interpreter to process the rest of the script. This exact location is significant on a Unix derived server (like the one Loyola’s Computer Science Department uses or any Mac with OS X). In Windows the only thing important is the distinction between Python 2 and 3. If you leave the line there as a part of your standard text, you have one less thing to think about when uploading to a Unix server or running on a Mac.

The first print function is telling the server receiving this output that the format of the rest of the output will be plain text. This information gets passed back to the browser later. This line should be included exactly as stated IF you only want the output to be plain text (the simplest case, but not our usual case).

The rest of the output (in this case just from one print function) becomes the body of the plain text document you see on your browser screen, verbatim since it is plain text. The server captures this output and redirects it to your browser.

**hellohtml.cgi**

We can make some variation and display an already determined html page rather than plain text. Try the link http://localhost:8080/hellohtml.cgi. The code is in the www example directory, hellohtml.cgi, and below for you to read:
```
#!/usr/bin/env python3

print("Content-Type: text/html\n\n")  # html markup follows

print("""
<html>
  <Title>Hello in HTML</Title>
<body>
  <p>Hello There!</p>
  <p><b>Hi There!</b></p>  
</body>
</html> """)
```
There are two noteworthy changes. The first print function now declares the rest of the output will be html. This is the standard line you will be using for your CGI programs. The remaining print function has the markup for an html page. Note that the enclosing triple quotes work for a multi line string. Other than as a simple illustration, this CGI script has no utility: Just putting the contents of the last print function in a file for a static web page hello.html is much simpler.

**now.cgi**

One more simple step: we can have a CGI script that generates dynamic output by reading the clock from inside of Python: Try the link http://localhost:8080/now.cgi. Then click the refresh button and look again. This cannot come from a static page. The code is in the www example directory, now.cgi, and below for you to read:
```
#!/usr/bin/env python3

import time
print("Content-Type: text/html\n\n")  # html markup follows

timeStr = time.strftime("%c") # obtains current time

htmlFormat = """
<html>
  <Title>The Time Now</Title>
<body>
  <p>The current Central date and time is:  {timeStr}</p>
</body>
</html> """

print(htmlFormat.format(**locals())) # see embedded %s ^ above
```
This illustrates a couple more ideas: First a library module, time, is imported and used to generate the string for the current date and time.

The web page is generated like in helloWeb2.py, embedding the dynamic data (in this case the time) into a literal web page format string. (Note the embedded {timeStr}.) Unlike helloWeb2.py, this is a CGI script so the web page contents are delivered to the server just with a print function.

**adder.cgi**

It is a small further step to get to processing dynamic input. Try filling out and submitting the adder form one more time, http://localhost:8080/adder.html. This time notice the URL at the top of the browser page when the result is displayed. You should see something like the following (only the numbers should be the ones you entered):http://localhost:8080/adder.cgi?x=24&y=56

This shows one mechanism to deliver data from a web form to the CGI script that processes it. The names x and y are used in the form (as we will see later) and the data you entered is associated with those names. In fact a form is not needed at all to create such an association: If you directly go to the URLs http://localhost:8080/adder.cgi?x=24&y=56 or http://localhost:8080/adder.cgi?x=-12345678924&y=33333333333

you get arithmetic displayed without the form. This is just a new input mechanism into the CGI script.

You have already seen a program to produce this adder page from inside a regular Python program taking input from the keyboard. The new CGI version, adder.cgi, only needs to make a few modifications to accept input this way from the browser. New features are commented in the source and discussed below. The new parts are the import statement through the main function, and the code after the end of the fileToStr function. Read at least these new parts in the source code shown below:
```
#!/usr/bin/env python3

import cgi   # NEW

def main(): # NEW except for the call to processInput
    form = cgi.FieldStorage()      # standard cgi script lines to here!
    
    # use format of next two lines with YOUR names and default data
    numStr1 = form.getfirst("x", "0") # get the form value associated with form
                                   # name 'x'.  Use default "0" if there is none. 
    numStr2 = form.getfirst("y", "0") # similarly for name 'y'
    contents = processInput(numStr1, numStr2)   # process input into a page
    print(contents)
    
def processInput(numStr1, numStr2):  
    '''Process input parameters and return the final page as a string.'''
    num1 = int(numStr1) # transform input to output data
    num2 = int(numStr2)
    total = num1+num2
    return fileToStr('additionTemplate.html').format(**locals())

# standard code for future cgi scripts from here on
def fileToStr(fileName): 
    """Return a string containing the contents of the named file."""
    fin = open(fileName); 
    contents = fin.read();  
    fin.close() 
    return contents

try:   # NEW
    print("Content-type: text/html\n\n")   # say generating html
    main() 
except:
    cgi.print_exception()                 # catch and print errors
```
First the overall structure of the code:

* To handle the CGI input we import the cgi module.

* The main body of the code is in a main method, following good programming practice.

* After the definition of main come supporting functions, each one copied from the earlier local web page version, additionWeb.py.

* At the end is the new, but standard, cgi wrapper code for main(). This is code that you can always just copy. I chose to put the initial print function here, that tells the server html is being produced. That mean the main method only needs to construct and print the actual html code. Also keep the final try-except block that catches any execution errors in the program and generates possibly helpful trace information that you can see from your browser. (Writing such error catching code in general is not covered in this introductory tutorial, but you can copy it!)

The main function has three sections, as in the local web page version: read input (this time from the form), process it, and generate the html output.

* Reading input: The first line of main is a standard one (to copy) that sets up an object called form that holds the CGI form data accompanying the web request sent by the browser. You access the form data with statements like the next two that have the pattern:

**variable** = form.getfirst( nameAttrib , default )

  If there is a form field with name nameAttrib, its value from the browser data is assigned to variable. If no value is given in the browser’s data for nameAttrib, variable is set equal to default instead.

  In this way data associated with names given by the browser can transferred to your Python CGI program. In this program the values associated with the browser-supplied names, ‘x’ and ‘y’, are extracted. I use Python variable names that remind you that all values from the browser forms are strings.

* The processInput function that is passed the input parameters from whatever source, is exactly the same as in additionWeb.py, so we already know it works!

* Output the page. In a CGI script this is easier than with the local web pages: just print it - no need to save and separately display a file! The server captures the “printed” output.

This program can now serve as a template for your own CGI scripts: The only things you need to change are the lines in main() that get the input from a web form, and the contents of processInput. Furthermore the processInput part can be written and tested earlier with a local web page. While this is the only Python code, you still need to create an output web page template, and refer to it in the parameter of fileToStr. A further stripped down skeleton, with comments about needed changes is in skeletonFor.cgi.

Now we have discussed both the top regular Python sequence, the bottom cgi sequence, and the common part in the middle, as shown in the following diagram. In both cases input data gets processed into the content of a web page that goes to a browser. For any major application the main work is in the processing in the middle. Since that part is shared in both approaches, it can be tested with a simple Python program, before the starting and ending steps for the input and output flow are changed for the cgi client/server model.

The only part that still needs details explained is for web forms. Before going on to that, it is time to talk about handling errors in the CGI scripts we have been discussing.

### Errors in CGI Scripts
Before you start running your own CGI scripts on the local server, it is important to understand how different kinds of errors that you might make will be handled.

If you write a regular Python program, even one that produces a web page, you can write the code and run it in Idle, and idle will display all the kinds of errors.

With a CGI script, you can still use Idle to write your code, but you cannot run the cgi code in Idle, and errors show up in three different places, depending on their type:

**Syntax errors**

You are encouraged to check for syntax errors inside Idle, by either going to the Run menu and selecting Check Module, or by using the shortcut Alt-X. If you fail to do this and try running a script with a syntax error, the error trace appears in the console window that appears when you start the local server. If you want an illustration, you might try changing adder.cgi, making an error like impor cgi, and try using adder.html with the flawed script. (Then fix it and try again.)

**Execution Errors**

The error trace for execution errors is displayed in your web browser, thanks to the final standard code with the try-catch block at the end of the CGI script. If you omit that final standard code, you completely lose descriptive feedback: Be sure to include that standard code! You can also illustrate here. Get an error by introducing the statement:
```
bad = 'a'.append('b')
```
in the main function. (Then take it out.)

**Server Errors**

Your work can cause an issue inside the local server, not directly in the Python execution. Some errors are communicated to the browser, but not necessarily all. Other errors appear in the log generated in the local server’s window. It does not appear likely that you will miss something in Windows, but on a Mac or in Linux, where the CGI script needs to be set as executable, an error with a non-executable CGI script only shows up in this log in the local server window.

**Logical Errors**

Since your output appears in the web browser, when you produced something legal but other than what you intended, you see in the browser . If it is a formatting error, fix your output page template. If you get wrong answers, check your processInput function.

Here is an outline for client/server program testing, emphasizing errors to be conscious of and avoid:

* If you want an easy environment to test a fancy processInput function, embed it in a regular Python program, so you can test it normally in Idle. This will also allow you to make sure the web template, that you refer to in your processInput function, is in a legitimate form, with substitutions only for local variables.

* You can code a CGI script in idle, but not run it. Be sure to save it with the suffix .cgi, not .py. Do not run it it Idle. The only testing you can do in Idle is for syntax, for instance using the Alt-X keyboard shortcut.

* At the end of your CGI script, make sure you include the standard code that catches execution errors.

* Make sure your local server is going, and that all the files you reference are in the same folder as the local server.

* Make sure you test your page by starting it in your web browser with a URL starting http://localhost:8080/. If you load a web page directly from your file system by mistake, it will not cause an obvious error - the dynamic actions will just not take place. If you are not paying attention, this can happen and be very confusing!

We have not covered web forms yet, but rather than bite off too much at once, this is a good time to write your own first CGI script in the following exercise.

### Editing HTML Forms
This section is a continuation of Introduction to Static Pages in Kompozer. It is about HTML editing, not Python. HTML forms will allow user-friendly data entry for Python CGI scripts. This is the last elaboration to allow basic web interaction: Enter data in a form, submit it, and get a processed result back from the server.

The initial example, adder.html, used only two text fields. To see more common form fields, open http://localhost:8080/commonFormFields.html. (Make sure your local server is still running!)

To allow easy concentration on the data sent by the browser, this form connects to a simple CGI script dumpcgi.cgi, that just dumps and labels all the form data to a web page. Press the submit button in the form, and see the result. Back up from the output to the previous page, the form, and change some of the data in all kinds of fields. Submit again and see the results. Play with this until you get the idea clearly that the form is passing on your data.

To play with it at a deeper level, open this same file, the www example commonFormFields.html, in Kompozer. The static text in this page is set up as a tutorial on forms in Kompozer. Read the content of the page describing how to edit the overall form and each type of individual field. Textbooks such as the Analytical Engine give another discussion of some of the attributes associated with each field type. Read the static text about how to edit individual fields, and change some field parameters, save the file and reload it in your browser, and submit again. If you change the name or value attributes, they are immediately indicated in the dumped output. If you change things like the text field size, it makes a change in the way the form looks and behaves. You can return to the original version: An extra copy is saved in commonFormFieldsOrig.html.

Now open adder.html in Kompozer. Switch to the Source view. This is a short enough page that you should not get lost in the source code. The raw text illustrates another feature of html: attributes. The tag to start the form contains not only the tag code form, but also several expressions that look like Python assignment statements with string values. The names on the left-hand side of the equal signs identify a type of attribute, and the string value after the equal sign gives the corresponding value for the attribute. The tag for many kinds of input fields is input. Notice that each field includes name and value attributes. See that the ‘x’ and ‘y’ that are passed in the URL by the browser come from the names given in the HTML code for the corresponding fields!

Kompozer and other web editors translate your menu selections into the raw html code with proper attribute types. This high level editor behavior is convenient to avoid having to learn and debug the exact right html syntax! On the other hand, using pop-up field editing windows has the disadvantage that you can only see the attributes of one field at a time. Particularly if you want to modify a number of name or value attributes, it is annoying that you need a number of mouse clicks to go from one field to the next. If you only want to modify the values of existing attributes like name and value, it may be easier to do in the source window, where you can see everything at once. Making syntax errors in not very likely if you only change data in quoted value strings.

The action URL is a property of the entire form. To edit it in Kompozer, right click inside the form, but not on any field element, and select the bottom pop-up choice, Form Properties. Then you see a window listing the Action URL and you can change the value to the name of the CGI script that you want to receive the form data. When you create your own web form, I suggest you make the initial action URL be dumpcgi.cgi. This will allow you to debug your form separate from your CGI script. When you have tested that your web form has all the right names and initial values, you can change the action URL to your CGI script name (like quotient.cgi), and go on to test the combination of the form and the CGI script!

Now we have discussed the last piece, web forms, in the diagram for the comparison of generating web pages dynamically by a regular Python program or a server CGI script:

This section is a continuation of Introduction to Static Pages in Kompozer. It is about HTML editing, not Python. HTML forms will allow user-friendly data entry for Python CGI scripts. This is the last elaboration to allow basic web interaction: Enter data in a form, submit it, and get a processed result back from the server.

The initial example, adder.html, used only two text fields. To see more common form fields, open http://localhost:8080/commonFormFields.html. (Make sure your local server is still running!)

To allow easy concentration on the data sent by the browser, this form connects to a simple CGI script dumpcgi.cgi, that just dumps and labels all the form data to a web page. Press the submit button in the form, and see the result. Back up from the output to the previous page, the form, and change some of the data in all kinds of fields. Submit again and see the results. Play with this until you get the idea clearly that the form is passing on your data.

To play with it at a deeper level, open this same file, the www example commonFormFields.html, in Kompozer. The static text in this page is set up as a tutorial on forms in Kompozer. Read the content of the page describing how to edit the overall form and each type of individual field. Textbooks such as the Analytical Engine give another discussion of some of the attributes associated with each field type. Read the static text about how to edit individual fields, and change some field parameters, save the file and reload it in your browser, and submit again. If you change the name or value attributes, they are immediately indicated in the dumped output. If you change things like the text field size, it makes a change in the way the form looks and behaves. You can return to the original version: An extra copy is saved in commonFormFieldsOrig.html.

Now open adder.html in Kompozer. Switch to the Source view. This is a short enough page that you should not get lost in the source code. The raw text illustrates another feature of html: attributes. The tag to start the form contains not only the tag code form, but also several expressions that look like Python assignment statements with string values. The names on the left-hand side of the equal signs identify a type of attribute, and the string value after the equal sign gives the corresponding value for the attribute. The tag for many kinds of input fields is input. Notice that each field includes name and value attributes. See that the ‘x’ and ‘y’ that are passed in the URL by the browser come from the names given in the HTML code for the corresponding fields!

Kompozer and other web editors translate your menu selections into the raw html code with proper attribute types. This high level editor behavior is convenient to avoid having to learn and debug the exact right html syntax! On the other hand, using pop-up field editing windows has the disadvantage that you can only see the attributes of one field at a time. Particularly if you want to modify a number of name or value attributes, it is annoying that you need a number of mouse clicks to go from one field to the next. If you only want to modify the values of existing attributes like name and value, it may be easier to do in the source window, where you can see everything at once. Making syntax errors in not very likely if you only change data in quoted value strings.

The action URL is a property of the entire form. To edit it in Kompozer, right click inside the form, but not on any field element, and select the bottom pop-up choice, Form Properties. Then you see a window listing the Action URL and you can change the value to the name of the CGI script that you want to receive the form data. When you create your own web form, I suggest you make the initial action URL be dumpcgi.cgi. This will allow you to debug your form separate from your CGI script. When you have tested that your web form has all the right names and initial values, you can change the action URL to your CGI script name (like quotient.cgi), and go on to test the combination of the form and the CGI script!

Now we have discussed the last piece, web forms, in the diagram for the comparison of generating web pages dynamically by a regular Python program or a server CGI script:

Note the last three Python videos do not directly corresponding to a single place in the Tutorial text. Instead they go through the entire process for web based programs from the beginning. Video 4.4.4b creates a birthday.html web form looking forward to birthday.cgi of video 4.4.4d. In the middle video 4.4.4c creates birthdayWeb.py, testing the process function and output template to be used in birthday.cgi.

### More Advanced Examples
One of the advantages of having a program running on a public server is that data may be stored centrally and augmented and shared by all. In high performance sites data is typically stored in a sophisticated database, beyond the scope of this tutorial. For a less robust but simpler way to store data persistently, we can use simple text files on the server.

The www example page namelist.html uses namelist.cgi to maintain a file namelist.txt of data submitted by users of the page. You can test the program with your local Python server. It is less impressive when you are the only one who can make changes! You may also try the copy on the public Loyola server, http://anh.cs.luc.edu/python/hands-on/3.1/examples/www/namelist.html. The local source code is documented for those who would like to have a look.

You also may want to look at the source code of the utility script you have been using, dumpcgi.cgi. It uses a method of getting values from the CGI data that has not been discussed:
```
val = form.getlist(name)
```
This method returns a list of values associated with a name from the web form. The list many have, 0, 1, or many elements. It is needed if you have a number of check boxes with the same name. (Maybe you want a list of all the toppings someone selects for a pizza.)

Both dumpcgi.cgi and namelist.html add an extra layer of robustness in reflecting back arbitrary text from a user. The user’s text may include symbols used specially in html like ‘<’. The function safePlainText replaces reserved symbols with appropriate alternatives.

The examples in earlier sections were designed to illustrate the flow of data from input form to output page, but neither the html or the data transformations have been very complicated. A more elaborate situation is ordering pizza online, and recording the orders for the restaurant owner. You can try http://localhost:8080/pizza1.cgi several times and look at the supporting example www files pizza1.cgi, pizzaOrderTemplate1.html, and the simple pizzaReportTemplate.html. To see the report, the owner needs to know the special name owner777. After ordering several pizzas, enter that name and press the Submit button again.

This CGI script gets used in two ways by a regular user: initially, when there is no order, and later to confirm an order that has been submitted. The two situations use different logic, and the script must distinguish what is the current use. A hidden variable is used to distinguish the two cases: when pizza1.cgi is called directly (not from a form), there is no pastState field. On the other hand the pizzaOrderTemplate1.html includes a hidden field named pastState, which is set to the value 'order'. (You can confirm this by examining the end of the page in Kompozer’s source mode.) The CGI script checks the value of the field pastState, and varies its behavior based on whether the value is 'order' or not.

The form in pizzaOrderTemplate1.html has radio buttons and check boxes hard coded into it for the options, and copies of the data are in pizza1.cgi. Keeping multiple active copies of data is not a good idea: They can get out of sync. If you look at the source code for pizzaOrderTemplate1.html, you see that all the entries for the radio button and check box lines are in a similar form. In the better version with altered files pizza.cgi and pizzaOrderTemplate.html (that appears the same to the user), the basic data for the pizza options is only in one place in pizza.cgi, and the proper number of lines of radio buttons and check boxes with the right data are generated dynamically. To do the dynamic generation, a templates for an individual html line with a size radio button is in the source code, and it is used repeatedly to generate multiple lines, each with a different size and price embedded into the format string from the program data. These lines are joined together and placed as one entity into the html form template. A similar procedure is done with the toppings and checkboxes.

A further possible elaboration would be to also allow the restaurant manager to edit the size, cost and available topping data online, and store the data in a file rather than having the data hard coded in pizza.cgi, so if the manager runs out of a topping, she can remove it from the order form. This change would be a fairly elaborate project compared to the earlier exercises!

## Summary
The Overall Process for Creating Dynamic Web Pages

1. Making dynamic web pages has a number of steps. I have suggested several ways of decoupling the parts, so you can alter the order, but if you are starting from nothing, you might follow the following sequence:

    1. Determine the inputs you want to work with and make a web form that makes it easy and obvious for the user to provide the data. You may initially want to have the form’s action URL be dumpcgi.cgi, so you can debug the form separately. Test with the local server. When everything seems OK, make sure to change the action URL to be the name of the CGI script you are writing. [Editing HTML Forms]

    2. It is easier to debug a regular Python program totally inside Idle than to mix the Idle editor and server execution. Particularly if the generation of output data is going to be complicated or there are lots of places you are planning to insert data into an output template, I suggest you write the processInput function with its output template first and test it without a server, as we did with additionWeb.py, providing either canned input in the main program, or taking input data from the keyboard, and saving the output page to a local file that you examine in your webbrowser. [Dynamically Created Static Local Pages from Python]

    3. When you are confident about your processInput function, put it in a program with the proper cgi skeleton, and add the necessary lines at the beginning of the main function to take all the CGI script input from the browser data. [adder.cgi]

    4. Be sure to check for syntax errors in Idle, for instance using Alt-X. Fix as necessary.

    5. Finally test the whole thing with the local server. Make sure the local server is running, and all the resources that you refer to are in the same folder as the local web server: Initial web page, web page templates, CGI script. Do not open the starting web page or CGI script in Idle or by finding it in your file system. You must run it in your browser with a URL that starts with http://localhost:8080/. In error, if you load a web page directly from your file system, it will not cause an obvious error - the dynamic actions will just not take place.

    6. If is does not work right:
    
        * If you get a page that uses your template, but it looks wrong, either fix your template or look for a logical error in your program. (If you had tested your processInput function in a regular Python program before, this should not happen.)
    
        * If the web page output shows an error description, see if you can pick any help out and go back and fix your code.
    
        * If you get nothing back in your web browser, make sure you had tested the final version of the code in Idle for syntax errors (Alt-X), and that you have the final error catching code in the CGI script, and that you used a URL that starts with http://localhost:8080/.
    
        * If all of the parts mentioned above are there, the problem may be with the server, not Python. Look in the local server window’s log output, and see if it points to a filename that it cannot find or ....
    
    7. If you have an account on a public server, it should not take much more work than just uploading your files to make your creation available to the whole world. You may have a public server with a different configuration than the Loyola server. If so see this note: 

2. Markup: Plain text may be marked up to include formatting. The formatting may be easily interpreted only by a computer, or it may be more human readable. One form of human-readable markup is hypertext markup language (HTML). [Format of Web Page Markup]

        1. HTML markup involves tags enclosed in angle braces. Ending tags start with ‘/’. For instance <title>Computer Science</title>.Tags may be modified with attributes specified similar to Python string assignments, for example the text input field tag,
```
<input value="red" name="color" type="radio">
```
        2. Modern editors allow HTML to be edited much like in a word processor. Two views of the data are useful: the formatted view and the source view, showing the raw HTML markup.

3. Python and HTML: Since HTML is just a text string, it can easily be manipulated in Python, and read and written to text files. [Dynamically Created Static Local Pages from Python]

4. The webbrowser module has a function open, that will open a file or web URL in the default browser: [Dynamically Created Static Local Pages from Python]
```
webbrowser.open( filename )
```

5. Common Gateway Interface (CGI). The sequence of events for generating a dynamic web page via CGI: [An Example in Operation]

    * The data a user types is handled directly by the browser. It recognizes forms.
    
    * The user presses a Submit button. An action is stored in the form saying what to do when the button is pressed.

    * In the cases we consider in this tutorial, the action is given as a web resource, giving the location of a CGI script on some server. The browser sends the data that you entered to that web location.

    * The server recognizes the page as an executable script, sees that it is a Python program, and executes it, using the data sent along from the browser form as input.

    * The script runs, manipulates the input data into some results, and puts those results into the text of a web page that is the output of the program.

    * The server captures this output from the program and send it back to the user’s browser as a new page to display.

    * The results appear in the user’s browser.

6. The cgi Module
   * Create the object to process CGI input with [adder.cgi]
    ```
    form = cgi.FieldStorage()
    ```
    * Extract the first value specified by the browser with name nameAttrib, or use default if no such value exists [adder.cgi]
    ```
    variable = form.getfirst( nameAttrib , default )
    ```
   * Extract the list of all values specified by the browser associated with name nameAttrib [ref{More Advanced Examples]
   ```
   listVariable = form.getlist( nameAttrib )
    ```
   This case occurs if you have a number of checkboxes, all with the same name, but different values. The list may be empty.

7. Local Python Servers.

    * Python has modules for creating local testing servers that can handle static web pages and Python CGI scripts.[An Example in Operation]
    
    * Different kinds of errors with CGI scripts are handled different ways by a local Python server. [Errors in CGI Scripts]
    
8. A comparison of the various types of files used in web programming, listing the different ways to edit and use the files, is given in Editing and Testing Different Document Formats.

The tutorial assumed a server configured as follows: html pages and CGI scripts can all be in the same directory, and the CGI scripts end with .cgi. This is the convention on Loyola’s Computer Science public server. Another common configuration is that scripts all go in a cgi-bin directory, where they just have the normal .py suffix. If you have a server with the latter configuration, your action URLs will be of the form cgi-bin/someScript.py. Depending on the server configuration the current directory may or may not be cgi-bin while the script executes. That may mean you need a path before the file names for your output templates, or your need to be careful what directory referenced files end up in. If you are making arrangements for your own site on a public server, be sure to check with your system administrator to find out what the conventions are.
